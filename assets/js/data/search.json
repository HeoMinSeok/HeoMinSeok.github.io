[
  
  {
    "title": "[유데미x스나이퍼팩토리] 프로젝트 캠프 : Next.js 2기 - 학습 일지 Week2",
    "url": "/posts/%ED%95%99%EC%8A%B5%EC%9D%BC%EC%A7%80-(2)/",
    "categories": "Next.js 직무교육, 회고록",
    "tags": "유데미, udemy, 웅진씽크빅, 스나이퍼팩토리, Next.js",
    "date": "2024-07-26 00:00:00 +0900",
    





    
    "snippet": "2주차2024.07.22 ~ 2024.07.26🐥 2주차 회고🐣 학습 내용1일차: React의 기본 개념 및 css 스타일링  react 프로젝트 생성 (vite)  react 이론          리액트의 기본 개념 + virtual DOM      확장자        react component          클래스, 함수 컴포넌트      컴포...",
    "content": "2주차2024.07.22 ~ 2024.07.26🐥 2주차 회고🐣 학습 내용1일차: React의 기본 개념 및 css 스타일링  react 프로젝트 생성 (vite)  react 이론          리액트의 기본 개념 + virtual DOM      확장자        react component          클래스, 함수 컴포넌트      컴포넌트 작성 방법        컴포넌트 css 스타일링          inline, external, css-modules, tailwind, css-in-js      2일차: React 컴포넌트 기본 문법  컴포넌트 생성          함수형으로 생성        컴포넌트 이벤트  컴포넌트 props          클릭 이벤트의 이해 및 props 전달 이해        컴포넌트 children          UI 컴포넌트 작성하고, children props 이해        tailwind-merge          클래스 충돌 해결 및 가독성 향상      3일차: React 컴포넌트 기본 문법 및 Hook  렌더링          특정 상황일 때 (조건)일 때만, 렌더링 시키기 (if, 삼항 연산자, 논리 연산자, 즉시 실행 함수)      특정 컴폰넌트 반복 출력 이해      다양한 이미지 렌더링 이해      특정 컴폰넌트 반복 출력 이해        Hook          useState : 리액트 상태 변수를 선언하고 관리      useId : 고유 id 생성 uuid      useRef : Dom 조작        TodoList 구현          주어진 피그마 UI를 받아 직접 퍼블리싱      앞서 배운 이벤트, tailwind, hook 총 집합해서 구현      4일차: 메모이제이션, Context API  메모이제이션          useCallback의 이해      useMemo의 이해      React.memo의 이해      useRefucer의 이해        Context API5일차: Zustand 및 API 통신, Routing  Zustand  useEffect  API 통신          json-server      fetch        Routing 🐣 개인적인 소감이번 주는 React를 복습하는 한 주였다. 내가 그동안 알고있던 내용들을 되짚어보는 시간이였고, 잘못 알고있던 내용들도 다시 정확하게 알아가는 시간이였다. 특히, 라우팅을 그동안 나는 구버전을 사용하고 있었는데, 이번 수업을 통해 새로운 버전을 익히게 되었다. 사실 구버전이 잘 돌아가길래 방식이 잘못된지 인지하지 못 하고 있었다. 그리고 기존에 JSX로만 리액트를 해왔었다. Zustand, Context API 등등, 평소에도 써왔었지만 tsx로는 처음이여서 타입 오류에 애를 먹었었다. 하지만, 강사님의 친절한 해설과 정확한 개념 설명을 통해 이제 타입 오류는 무섭지 않고 타입 선언 또한 자연스럽게 하고 있다…다음 주부터는 Next JS인데 많이 떨린다.. 잘 따라갔으면 좋겠다 !  학습 내용들의 정리는 React 카테고리에 ❗️              MINDDO    MINDDO의 코딩 기록장    heominseok.github.io  "
  },
  
  {
    "title": "[React + TypeScript] - Zustand",
    "url": "/posts/Zustand/",
    "categories": "📖, React",
    "tags": "React, TypeScript",
    "date": "2024-07-25 00:00:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "[React + TypeScript] - Context API, useReducer",
    "url": "/posts/Context-API-+-Reducer-%EC%A0%95%EB%A6%AC/",
    "categories": "📖, React",
    "tags": "React, TypeScript",
    "date": "2024-07-25 00:00:00 +0900",
    





    
    "snippet": "Context API - Props DrillingProps-Drliing 문제점  데이터를 전달하기 위해 많은 중간 컴포넌트들이 불필요하게 props를 받아서 다시 전달해야하는데, 이는 코드 가독성을 저하시킴  컴포넌트 트리가 변경되거나 중간에 새로운 컴포넌트를 추가하거나 제거해야 하는 경우, 모든 관련된 컴포넌트의 props를 업데이트해야해서 유지...",
    "content": "Context API - Props DrillingProps-Drliing 문제점  데이터를 전달하기 위해 많은 중간 컴포넌트들이 불필요하게 props를 받아서 다시 전달해야하는데, 이는 코드 가독성을 저하시킴  컴포넌트 트리가 변경되거나 중간에 새로운 컴포넌트를 추가하거나 제거해야 하는 경우, 모든 관련된 컴포넌트의 props를 업데이트해야해서 유지보수가 어려움  중간 컴포넌트들이 단순히 데이터를 전달하는 역할만 할 경우, 동일한 코드가 반복  특정 props를 전달하는 로직이 중간 컴포넌트에 포함되어 있는 경우, 이 컴포넌트를 재사용하기 어려워짐  props가 자주 변경되는 경우, 많은 컴포넌트가 불필요하게 리렌더링이를 해결하기 위한 여러 방법들 중 Context API, useReducer 등이 있다.Context API란?일일이 props를 넘겨주지 않고 컴포넌트 트리 전체에 데이터를 제공할 수 있는데, 이를 통해서 Props-Drilling 해결 가능Context API의 주요 구성 요소  React.createContext: Context 객체를 생성  Context.Provider: Context를 구독하는 컴포넌트들에게 Context 값을 제공  Context.Consumer: Context의 현재 값을 구독하여 사용, 일반적으로 Consumer 대신 useContext 훅을 사용DevTools에서 Context API 확인            컴포넌트 트리      Provider      Team      Player                                            컴포넌트 트리: 첫 번째 이미지는 DevTools에서 본 컴포넌트 트리이다. App 컴포넌트 아래에 TeamProvider가 있으며, 그 안에 Context.Provider가 있는데,ContextTeam과 ContextPlayer 컴포넌트는 Context.Provider의 자식으로 있어 Context.Provider의 props를 훅 호출로 사용할 수 있다.  Provider: Context.Provider는 teams 데이터를 포함하고 있으며, dispatch 함수와 state를 props로 전달하는데, 이를 통해 하위 컴포넌트들이 Context의 값을 사용할 수 있게 된다.  Team, Player: Context를 통해 전역으로 있는 데이터를 가져왔기 때문에 props 필드는 비어있는 것을 볼 수 있다.실제 코드에서도 컴포넌트에 props를 전달하지 않고, 해당 컴포넌트에서 Context를 호출해 데이터를 가져왔다./* useTeams는 ContextTeams를 커스텀 훅으로 만들었음 */const { teams, dispatch, state } = useTeams(); 이런 식으로 호출해서 필요한 데이터를 뽑아올 수 있음/* useTeams 커스텀 훅 */import { useContext } from 'react';import TeamContext from '../context/ContextTeams';const useTeams = () =&gt; {  const context = useContext(TeamContext);  if (!context) {    throw new Error('useTeams must be used within a TeamProvider');  }  return context;};export default useTeams;DevTools에서 Props Drilling 확인            컴포넌트 트리      부모 컴포넌트에서 Props 전달      Team      Player                                            컴포넌트 트리: 첫 번째 이미지는 DevTools에서 본 컴포넌트 트리이다. App 컴포넌트 아래에 DrillingTeam, DrillingPlayer가 있다.  props 전달: props를 자식 컴포넌트로 전달하는 코드 사진이다.  Team, Player: 이미지를 보면 명확하게 props로 데이터를 받아오는 것을 볼 수 있다.  실제 프로젝트에서는 데이터도 많고 한데, props로 일일이 다 전달하면 위에서 말한 문제점이 생겨나게 되는 것이다. Context API는 전역으로 상태를 담아주어서 따로 props를 컴포넌트마다 전달하지 않아도 useContext나 Context를 커스텀 훅에 담아서 값을 쉽게 뽑아올 수 있다. 하지만 Context도 구독하는 모든 컴포넌트가 값 변경될 때마다 리렌더링 되어 성능에 문제가 생길 수 있다.Reducer란?하나의 컴포넌트 내에서 state를 다루는 로직을 해당 컴포넌트로 분리하여 외부에서 처리 할 수 있게 해줌useReducer FlowuseReducer의 주요 구성 요소  State: 현재 컴포넌트의 상태  Dispatch: 상태를 업데이트하는 함수, 특정 액션을 dispatch 함수에 전달하면, 이 액션에 따라 상태가 업데이트  Reducer: 상태 업데이트 로직을 정의하는 함수, 이 함수는 현재 상태와 액션 객체를 인수로 받아 새로운 상태를 반환useReducer의 흐름  EventHandler: 컴포넌트에서 이벤트 핸들러가 호출  Dispatch: 이벤트 핸들러는 dispatch 함수를 호출하여 액션 객체를 전달  Reducer: dispatch 함수는 액션 객체를 reducer 함수로 전달  State Update: reducer 함수는 현재 상태와 액션 객체를 기반으로 새로운 상태를 반환  Component Re-render: 상태가 업데이트되면 컴포넌트가 다시 렌더링DevTools에서 useReducer 확인    1.각 팀의 버튼을 누른다. 2.dispatch 함수가 호출되어 액션 객체를 reducer 함수로 전달한다. 3.reducer 함수는 현재 상태와 액션 객체를 기반으로 새로운 상태를 반환한다. 즉, 해당 팀의 선수를 반환한다. 4.상태가 업데이트되면 컴포넌트가 다시 렌더링된다.이와 같이 useReducer를 사용하면 복잡한 상태 로직을 컴포넌트 내에서 효율적으로 관리할 수 있다. useReducer는 특히 상태 업데이트 로직이 복잡하거나 여러 액션 타입을 처리해야 할 때 유용하다.예제 코드              Voiteks - Vote (forked)    StackBlitz    stackbiltz.com  "
  },
  
  {
    "title": "[유데미x스나이퍼팩토리] 프로젝트 캠프 : Next.js 2기 - 학습 일지 Week1",
    "url": "/posts/%ED%95%99%EC%8A%B5%EC%9D%BC%EC%A7%80/",
    "categories": "Next.js 직무교육, 회고록",
    "tags": "유데미, udemy, 웅진씽크빅, 스나이퍼팩토리, Next.js",
    "date": "2024-07-20 00:00:00 +0900",
    





    
    "snippet": "1주차2024.07.15 ~ 2024.07.19🐥 참가하게 된 계기백엔드 개발을 주로 해왔었는데 프론트엔드 기술을 배우기 위해 Next.js 과정을 시작하게되었다.  스프링부트와 자바만 주구장창 하던 내가… 몇개월 전에 리액트를 접하게 되었는데 너무나도 재미있고 나에게 잘 맞았다… 그러다가 Next JS를 알게되었고 프론트엔드쪽도 깊게 공부해서 프론트...",
    "content": "1주차2024.07.15 ~ 2024.07.19🐥 참가하게 된 계기백엔드 개발을 주로 해왔었는데 프론트엔드 기술을 배우기 위해 Next.js 과정을 시작하게되었다.  스프링부트와 자바만 주구장창 하던 내가… 몇개월 전에 리액트를 접하게 되었는데 너무나도 재미있고 나에게 잘 맞았다… 그러다가 Next JS를 알게되었고 프론트엔드쪽도 깊게 공부해서 프론트엔드와 백엔드를 모두 다룰 수 있는 풀스택 개발자가 되기 위해 이번 과정에 참여하였다 🤟🐥 1주차 회고          온라인            오프라인  🐣 개인적인 소감  이태원에서 왔다갔다 했는데 너무 힘들었다.. 길도 너무 복잡하고 경사도 높고.. 심지어 수요일부터는 비가 너무 너무 많이 와서 신발이 아쿠아슈즈가 되어버렸다..  온 몸은 찝찝하고 휴.. 😥 그래도 수업은 너무나도 알찼다 ! 수코딩 강사님이 하셨는데 너무 잘 가르쳐주셨다 !  본인은 자바와 파이썬만 주로 다루어왔어서 자바스크립트를 깊게 공부하지 않았었다.. 그게 조금 걱정이였는데 다시 기본 개념과 문법을 학습하며 ES6의 기능들을 되짚어보았고 까먹었던 내용들을 다시 되짚어보게 되었다 ❗️❗️ 감사합니다 강사님 😝  다음주부터는 나는 온라인으로 참가해야한다 ! 본가로 내려와서 더이상 강의장으로 갈 수가 없다 .. 새로 사귄 분들이 있었는데 못 보게 된게 조금 아쉽다 1주동안 재밌었는데…! 프로젝트 시작하면 다시 봐요 🥹🐣 개념정리이번 주에는 JavaScript 기초 개념을 다루었다.  JavaScript 기본 문법: 변수 선언(var, let, const), 자료형, 조건문, 반복문, 연산자  함수: 함수 선언과 표현식, 화살표 함수, 콜백 함수  객체와 배열: 객체 생성, 배열의 메서드 활용, 프로토타입, 클래스  실행 컨텍스트와 호이스팅  내장 객체 및 메서드  비동기 프로그래밍: 동기 및 비동기 처리 Promise~then, async/await  DOM 조작: DOM 요소 선택과 이벤트 처리  TypeScript: 기본 타입 이해  본 내용들의 정리는 JavaScript 카테고리에 ❗️              MINDDO    MINDDO의 코딩 기록장    heominseok.github.io  🐣 과제 요구사항  2일차: 반복문과 조건문  for 반복문: 주어진 범위 내에서 반복 작업을 수행  조건문(if-else): 조건에 따라 서로 다른 작업을 수행  요구사항          ✔️ 반복문을 통해 숫자나 배열의 요소들을 순회하고 처리      ✔️ 조건문을 통해 특정 조건에 따라 분기 처리        3일차: 함수와 문자열 조작  함수 선언 및 호출: 특정 작업을 수행하는 코드를 재사용 가능하도록 정의  문자열 조작: 문자열을 변환하고 필요한 형식으로 가공      요구사항          ✔️ 함수를 작성하여 반복적인 작업을 모듈화하고 재사용성을 높임      ✔️ 문자열을 조작하여 원하는 형식으로 변환        4일차: 내장 객체 및 메서드  배열 메서드(find, filter, some, every, reduce, sort): 배열 내 요소를 찾거나, 필터링하거나, 조건을 확인하거나, 합산하거나, 정렬하는 작업을 수행  문자열 메서드(replace, split): 문자열을 변환하고 특정 구분자로 분리하여 배열을 생성  고급 배열 메서드를 활용하여 데이터를 처리하고 분석      요구사항          ✔️ 배열의 다양한 메서드를 사용하여 데이터를 처리하고 필요한 결과를 도출      ✔️ 문자열 메서드를 활용하여 문자열을 변환하고 필요한 형식으로 가공      "
  },
  
  {
    "title": "[TypeScript] 기본 문법",
    "url": "/posts/%EC%88%98%EC%97%85-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC-(6)/",
    "categories": "📖, TypeScript",
    "tags": "TypeScript",
    "date": "2024-07-19 00:00:00 +0900",
    





    
    "snippet": "1️⃣ 타입스크립트 기본 타입Stringlet color: string = \"blue\";Numberlet decimal: number = 6;Booleanlet isDone: boolean = true;Arraylet list: number[] = [1, 2, 3];let list: Array&lt;number&gt; = [1, 2, 3];Object...",
    "content": "1️⃣ 타입스크립트 기본 타입Stringlet color: string = \"blue\";Numberlet decimal: number = 6;Booleanlet isDone: boolean = true;Arraylet list: number[] = [1, 2, 3];let list: Array&lt;number&gt; = [1, 2, 3];Objectconst user:object = { name:\"민또\", age:19 }Tuple ➡️ 고정된 개수의 요소를 가지며 각 요소의 타입이 지정된 배열const arr: [string, number] = ['Bellingham', 22];Null / Undefinedlet u: undefined = undefined;let n: null = null;Any ➡️ 어떤 타입이든 상관 Xlet notSure: any = 4;그 외 ➡️ Enum, Never, Void🚀 함수 타입1️⃣ 매개변수 타입 지정function add(x: number, y: number): { return x + y };add(10, 20); // 가능add(\"x\", \"y\") // 불가능2️⃣ 반환 값 타입 지정function add(x, y):number { return x + y }; // 반환 값 반드시 Number 형3️⃣ 옵셔널 파라미터  선택적 매개변수는 \"?\"를 사용하여 정의function optionalName(firstName: string, lastName?: string): string {  if(lastName) {    return firstName + \" \" + lastName;  } else {    return firstName;  }}console.log(optionalName(\"Minddo\", \"Heo\")); // Minddo Heoconsole.log(optionalName(\"Minddo\")); // Minddo🚀 타입 오퍼레이터1️⃣ 유니언 타입      유니언 타입은 여러 개의 타입을 결합하여 변수에 할당할 수 있는 값을 다양하게 만들 수 있음    유니언 타입은 연결된 타입 중 1개만 만족하면 됨  let value: string | number;value = \"minddo\"; // OKvalue = 19; // OK  But 특정 타입의 메소드를 사용하려고 하면 에러가 발생 할 수 있음  ☝🏻 때문에 Type Guard 사용하기  Type Guard ➡️ 런타임에 변수의 타입 확인 후, 그에 따라 해당 타입의 메소드 사용할 수 있도록 해줌  typeof 연산자 사용한 타입 가드          원시 타입 확인에 유용        function printId(id: number | string) {if (typeof id === \"string\") {// id가 string 타입인 경우console.log(`ID (string): ${id.toUpperCase()}`);} else {// id가 number 타입인 경우console.log(`ID (number): ${id}`);}}                      instanceof 연산자 사용한 타입 가드          객체가 특정 클래스의 인스턴스인지 확인할 때 사용      코드 보기    class ManchesterUTD {  utd() {    console.log(\"근본\");  }}class ManchesterCity {  city() {    console.log(\"노근본\");  }}type Club = ManchesterUTD | ManchesterCity;function favorite(club: Club) {  if (club instanceof ManchesterUTD) {    club.utd();  } else {    club.city();  }}let mu = new ManchesterUTD();let mc = new ManchesterCity();favorite(mu); favorite(mc);       2️⃣ 인터섹션 타입      인터섹션 타입은 여러 타입을 결합하여 하나의 복합 타입을 만들 수 있음    인터섹션 타입은 연결된 타입을 모두 만족해야함  const introduce: { name: string; age: number } &amp; { job: string } = {  name: \"Bellingham\",  age: 22,  job: \"Soccer Player\",};🚀 인터페이스  객체의 타입을 정의할 때 사용하는 도구1️⃣ 기본 인터페이스 정의interface Person {  name: string;  age: number;}let person: Person = {  name: \"minddo\",  age: 29};2️⃣ 인터페이스 병합interface Person {  name: string;}interface Person {  age: number;}const player: Person = {  name: \"Bellingham\",  age: 22};3️⃣ 인터페이스 상속interface Club {  uniformColor: string;}interface ManUtd extends Club {  country: string;}const player: Person = {  uniformColor: \"Red\",  country: \"England\"};4️⃣ 인덱스 시그니처  객체가 임의의 속성을 가질 수 있도록 정의interface ClubDictionary {  [key: string]: string | number;}let manU: ClubDictionary = {  name: \"ManchesterUtd\",  rank: 1,  country: \"England\",  stadium: \"Old Trafford\"};console.log(manU);🐥 변수에 인터페이스 적용interface User {  username: string;  password: string;}const user: User = {  username: \"mingddo\",  password: \"1234\"}🐥 함수에 인터페이스 적용interface Login {  (username: string, password: string): boolean;}let login: Login;login = (username: string, password: string) =&gt; {  // 로그인 로직  return username === \"mingddo\" &amp;&amp; password === \"1234\";};console.log(login(\"mingddo\", \"1234\")); // trueinterface IPerson {  name: string;  age: number;}const averageAge = (people: IPerson[]): number =&gt; {  return people.reduce((acc, person) =&gt; acc + person.age, 0) / people.length;};const average = averageAge([  { name: \"Mingddo\", age: 30 },  { name: \"CutieMingddo\", age: 10 },  { name: \"You\", age: 50 },]);console.log(average); // 30🚀 타입 별칭(Type Aliases)  type 키워드를 사용해 타입을 지정  특정 타입에 별명을 붙여 재사용 가능하게 함  코드의 가독성 증가/* 객체 타입에 타입 별칭 */type Minddo = {  name: string;  age: number;};const minddo: Minddo = {  name: \"minseok\",  age: 25};/* 유니언 타입에 타입 별칭 */type Color = \"Red\" | \"Blue\" | \"Yellow\";const color: Color = \"Red\";/* 함수 타입에 타입 별칭 */type Stacks = {  name: string;  period: number;};const stacks = (stack: Stacks): string =&gt; {  return `Name: ${stack.name}, Period: ${stack.period}`;};const myStack: Stacks = { name: \"Java\", period: 8 };console.log(stacks(myStack)); // Name: Java, Period: 8🚀 Enum  enum은 관련된 값의 집합에 이름을 붙여주는 방법1️⃣ 숫자 열거형enum Direction {  Up,  Down,  Left,  Right}let direction: Direction = Direction.Up;console.log(direction); // 02️⃣ 문자 열거형enum Direction {  Up = \"UP\",  Down = \"DOWN\",  Left = \"LEFT\",  Right = \"RIGHT\"}let direction: Direction = Direction.Left;console.log(direction); // \"LEFT\"3️⃣ 이니셜라이즈된 열거형 (Const Enum)  const enum은 컴파일 타임 상수로 최적화되는 열거형  const enum은 런타임에 실제 객체로 존재하지 않음  컴파일 시점에 열거형 값이 상수로 대체 !const enum HttpStatus {  OK = 200,  BadRequest = 400,  Unauthorized = 401,  NotFound = 404}function handleResponse(status: HttpStatus): string {  switch (status) {    case HttpStatus.OK:       return \"Request was successful.\";    case HttpStatus.BadRequest:       return \"Bad request.\";    case HttpStatus.Unauthorized:      return \"Unauthorized access.\";    case HttpStatus.NotFound:      return \"Resource not found.\";    default:      return \"Unknown error.\";  }}const status = HttpStatus.OK;console.log(handleResponse(status)); // \"Request was successful.\"  위의 코드는 아래와 같이 컴파일된다.function handleResponse(status) {  switch (status) {    case 200 /* OK */:      return \"Request was successful.\";    case 400 /* BadRequest */:      return \"Bad request.\";    case 401 /* Unauthorized */:      return \"Unauthorized access.\";    case 404 /* NotFound */:      return \"Resource not found.\";    default:      return \"Unknown error.\";  }}var status = 200 /* OK */;console.log(handleResponse(status)); // \"Request was successful.\"  컴파일 타임에 상수 값으로 대체되어, 성능 최적화 가능  But, 디버깅 시에 원래 열거형 이름 확인 불가4️⃣ 문자열 및 숫자 혼합 열거형enum Mixed {  No = 0,  Yes = \"YES\"}console.log(Mixed.No); // 0console.log(Mixed.Yes); // \"YES\"🚀 제네릭  코드 작성 시점이 아닌 사용 시점에 타입을 정의하는데 이러한 점은 재사용 가능한 컴포넌트를 작성할 때 유용하고 타입 안정성을 유지하면서 유연하게 작성할 수 있음1️⃣ 제네릭 함수const identity = &lt;T&gt;(value: T): T =&gt; {  return value;};// 호출 시점 타입 지정 !let output1 = identity&lt;string&gt;(\"myString\");let output2 = identity&lt;number&gt;(123);console.log(output1); // \"myString\"console.log(output2); // 123// 타입 추론console.log(identity(42));       // 42console.log(identity(\"hello\"));  // \"hello\"2️⃣ 제네릭 인터페이스interface PlayerIdentityFn&lt;T&gt; {  (arg: T): T;}const playerIdentity: PlayerIdentityFn&lt;string&gt; = (playerName) =&gt; {  return playerName;};console.log(playerIdentity(\"Marcus Rashford\")); // Marcus Rashfordconsole.log(playerIdentity(\"Bruno Fernandes\")); // Bruno Fernandes3️⃣ 제네릭 클래스class PlayerStats&lt;T&gt; {  initialStat: T;  add: (x: T, y: T) =&gt; T;  constructor(initialStat: T, add: (x: T, y: T) =&gt; T) {    this.initialStat = initialStat;    this.add = add;  }}const goalStats = new PlayerStats&lt;number&gt;(0, (x, y) =&gt; x + y);console.log(goalStats.add(goalStats.initialStat, 5)); // 54️⃣ 제네릭 제약 조건interface Player {  name: string;  goals: number;}const printPlayerGoals = &lt;T extends Player&gt;(player: T): T =&gt; {  console.log(`${player.name} has scored ${player.goals} goals.`);  return player;};printPlayerGoals({ name: \"Marcus Rashford\", goals: 10, team: \"Man Utd\" });  Player 인터페이스는 name, goals 두 개의 속성을 가짐  printPlayerGoals 함수는 제네릭 타입 변수 T를 사용하며, 이 제네릭 타입은 Player 인터페이스를 확장함          ➡️ T는 Player 인터페이스와 동일하거나 이를 확장하는 타입이어야 함        printPlayerGoals 함수를 호출 할 때, Player 인터페이스는 name과 goals 속성만 포함하고 있기때문에 함수에서 player.team에 접근하려 하면 타입스크립트는 team 속성이 인터페이스에 정의되어 있지 않아 에러가 발생하는데 이러한 것이 타입 제약이라고 함"
  },
  
  {
    "title": "[JavaScript] - 기본 문법 (5)",
    "url": "/posts/%EC%88%98%EC%97%85-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC-(5)/",
    "categories": "📖, JavaScript",
    "tags": "JavaScript",
    "date": "2024-07-19 00:00:00 +0900",
    





    
    "snippet": "🚀 DOMDOM(Document Object Model)은 웹 페이지의 구조화된 표현으로, 자바스크립트를 사용하여 웹 페이지의 콘텐츠와 구조를 동적으로 조작할 수 있음1️⃣ DOM 요소 선택  getElementById() ➡️ ID로 요소 선택      let element = document.getElementById('myId');        ...",
    "content": "🚀 DOMDOM(Document Object Model)은 웹 페이지의 구조화된 표현으로, 자바스크립트를 사용하여 웹 페이지의 콘텐츠와 구조를 동적으로 조작할 수 있음1️⃣ DOM 요소 선택  getElementById() ➡️ ID로 요소 선택      let element = document.getElementById('myId');         getElementsByClassName() ➡️ 클래스 이름으로 요소 선택      let elements = document.getElementsByClassName('myClass');         getElementsByTagName() ➡️ 태그 이름으로 요소 선택      let elements = document.getElementsByTagName('div');         💥 querySelector() ➡️ CSS 선택자를 사용하여 첫 번째 일치 요소 선택      let elements = document.querySelector('.myClass');         💥 querySelectorAll() ➡️ CSS 선택자를 사용하여 모든 일치 요소 선택      let elements = document.querySelectorAll('.myClass');       2️⃣ DOM 요소 생성 및 추가  createElement() ➡️ 요소 생성      let newElement = document.createElement('div');  newElement.textContent = 'Hello, World!';        appendChild(), insertBefore() ➡️ 요소 생성      document.body.appendChild(newElement);      3️⃣ DOM 요소 속성 조작  setAttribute() ➡️ 속성 추가/수정      element.setAttribute('class', 'newClass');        removeAttribute() ➡️ 속성 제거      element.removeAttribute('class');        속성 접근      element.id = 'newId';  element.className = 'newClass';      4️⃣ DOM 요소 스타일 조작  style ➡️ 스타일 설정      element.style.color = 'red';  element.style.fontSize = '20px';      5️⃣ 이벤트 처리  addEventListener() ➡️ 이벤트 리스너 추가      element.addEventListener('click', function() {alert('Element clicked!');  });        removeEventListener() ➡️ 이벤트 리스너 제거      function handleClick() {alert('Element clicked!');  }  element.addEventListener('click', handleClick);  element.removeEventListener('click', handleClick);      "
  },
  
  {
    "title": "[JavaScript] - 기본 문법 (4)",
    "url": "/posts/%EC%88%98%EC%97%85-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC-(4)/",
    "categories": "📖, JavaScript",
    "tags": "JavaScript",
    "date": "2024-07-18 00:00:00 +0900",
    





    
    "snippet": "🚀 생성자 함수 /  프로토타입새로운 객체를 생성하고 초기화하는 함수      생성자 함수는 내부에서 this를 사용하여 생성될 객체의 속성 정의    프로토타입을 사용하여 메서드를 공유하여 코드의 재사용성을 높임              모든 객체는 프로토타입 객체로부터 속성과 메서드를 상속 받음            function Bellingham...",
    "content": "🚀 생성자 함수 /  프로토타입새로운 객체를 생성하고 초기화하는 함수      생성자 함수는 내부에서 this를 사용하여 생성될 객체의 속성 정의    프로토타입을 사용하여 메서드를 공유하여 코드의 재사용성을 높임              모든 객체는 프로토타입 객체로부터 속성과 메서드를 상속 받음            function Bellingham(born, height, club) {  this.born = born;  this.height = height;  this.club = club;}Bellingham.prototype.getPersonInfo = function() {  return `${this.born} ${this.height} ${this.club}`;}let myBellingham = new Car(`England`, `186cm`, `Real-Madrid`);console.log(MyBellingham.getPersonInfo()); // England 186cm Real-Madrid🚀 클래스클래스는 ES6부터 도입하였고, 객체 지향 프로그래밍을 쉽게 구현할 수 있게 해줌1️⃣ 클래스 선언class Person {  constructor(name, age) {    this.name = name;    this.age = age;  }  greet() {    console.log('Hello, ' + this.name);  }}let ronaldo = new Person('Ronaldo', 40);ronaldo.greet(); // Hello, Ronaldo  ✔️ constructor는 반드시 있어야함2️⃣ 클래스 선언은 함수 선언과 달리 호이스팅 ❎const bellingham = new Person('Bellingham', 22); // ReferenceError: Cannot access 'Person' before initializationclass Person {  constructor(name, age) {    this.name = name;    this.age = age;  }}3️⃣ 상속  클래스는 extends 키워드를 사용하여 다른 클래스 상속 가능class Employee extends Person {  constructor(name, age, job) {    super(name, age);    this.job = job;  }  work() {    console.log(this.name + ' is working as a ' + this.job);  }}let kane = new Employee('Kane', 32, 'soccer-player');kane.greet(); // Hello, kanekane.work();  // kane is working as a soccer-player4️⃣ static  static 키워드를 사용하여 클래스의 인스턴스가 아닌 클래스 자체에 속하는 메서드와 속성을 정의할 수 있음class UserService {  static async login(email, password) {        const isLogin(email, password){          console.log(\"로그인하셨습니다\")        }        return { email, password };    }    // 회원가입    static async signup(userData) {        const isSignup(userData){          console.log(\"회원가입하셨습니다\")        }        return userData;    } }console.log(UserService.login(\"kanekane\", 1234)); // 로그인하셨습니다console.log(UserService.signup({ name: \"Bellingham\", age: 22 })); // 회원가입하셨습니다5️⃣ getter / setter  클래스 내 속성에 접근 및 설정을 할 수 있음class Person {  constructor(name) {    this._name = name;  }  get name() {    return this._name;  }  set name(newName) {    if (newName) {      this._name = newName;    }  }}let person = new Person('Messi');console.log(person.name); // Messiperson.name = 'Walker';console.log(person.name); // Walker6️⃣ 오버라이딩  상위 클래스 메서드를 하위 클래스에 재정의(오버라이딩) 가능class Club {  name() {    console.log('Club Name');  }}class Soccer extends Club {  name() {    console.log('Manchester UTD');  }}let myClub = new Soccer();myClub.name(); // Manchester UTD🚀 내장 객체1️⃣ 표준 내장 객체표준 내장 객체는 자바스크립트 엔진에 기본으로 내장되어있고, 별도 선언 없이 사용 가능  Object  Function  Array  String  Boolean  Number  Math  Date  RegEXP2️⃣ 배열 내장 객체  주요 메서드  push() ➡️ 배열 끝에 요소 추가  pop() ➡️ 배열 끝에 요소 제거  shift() ➡️ 배열 첫 번째 요소 제거  unshift() ➡️ 배열 앞에 요소 추가  join() ➡️ 배열을 매개변수와 조합하여 합침  sort ➡️ 배열 정렬  reverse() ➡️ 배열 역순으로 뒤집음  mpa(), filter(), reduce() ➡️ 배열 순회하여 작업 수행3️⃣ 문자 내장 객체  주요 메서드  charAt() ➡️ 특정 인덱스 문자 반환  split() ➡️ 문자열을 separator 기준으로 분리하여 배열 만듬  concat() ➡️ 매개변수로 전달되어진 문자열을 하나의 문자열로 합침  indexOf() ➡️ 특정 문자의 인덱스를 반환  includes() ➡️ 문자열에 특정 문자열이 포함되어 있는지 확인  slice() ➡️ 문자열의 일부분을 추출  toUpperCase(), toLowerCase(() ➡️ 대소문자 변환  substring() ➡️ 부분 문자열 반환4️⃣ Math 객체  주요 메서드  Math.abs() ➡️ 절대값 반환  Math.ceil(), Math.floor() ➡️ 올림, 내림  Math.max(), Math.min() ➡️ 최대값, 최소값 반환  Math.random() ➡️ 0과 1 사이의 난수 생성  Math.min() ➡️ 주어진 숫자 중 제일 낮은 숫자를 반환  Math.round() ➡️ 소수점을 반올림  Math.floor() ➡️ 소수점을 내림  Math.ceil() ➡️ 소수점을 올림  Math.abs() ➡️ 절대값을 반환  Math.pow(x, y) ➡️ x의 y 제곱을 반환🚀 동기 / 비동기동기 : 코드가 순차적으로 실행, 이전 코드 완료전 까지 다음 코드 실행 X비동기 : 코드가 병렬로 실행, 다른 코드 실행 방해 X1️⃣ 콜백함수콜백 함수는 다른 함수의 인수로 전달되어 실행되는 함수  동기식 콜백(synchronous callback)          호출되는 즉시 실행되고, 그 작업이 완료될 때까지 다음 코드를 실행 ❎        function syncCallback(callback) {  console.log(\"콜백 전\");  callback();  console.log(\"콜백 후\");}syncCallback(() =&gt; {  console.log(\"내부 콜백\");});// 출력:// 콜백 전// 내부 콜백// 콜백 후        비동식 콜백(asynchromous callback)          비동기식 콜백은 호출된 후 비동기 작업이 완료된 후에 실행        function asyncCallback(callback) {  console.log(\"콜백 전\");  setTimeout(() =&gt; {    callback();    console.log(\"내부 콜백\");  }, 1000);  console.log(\"콜백 후\");}asyncCallback(() =&gt; {  console.log(\"콜백 실행됨\");});// 출력:// 콜백 전// 콜백 후// 1초 후// 콜백 실행됨// 내부 콜백      2️⃣ Promise ThenPromise는 비동기 작업의 완료 또는 실패를 나타내는 객체, then 메서드 사용하여 처리를 정의  Promise는 3개의 상태를 가짐  대기 : 초기상태  이행 : 연산 완료  거부 : 연산 실패  let promise = new Promise((resolve, reject) =&gt; {  let success = true; // 작업 성공 여부    setTimeout(() =&gt; {      if (success) {        resolve('Data fetched successfully'); // 이행 상태      } else {        reject('Error in fetching data'); // 거부 상태      }    }, 2000);  });  &gt;&gt; then 메서드 체이닝  - 첫 번째 인수는 프로미스가 이행된 경우에 호출되는 콜백 함수  - 두 번째 인수는 거부된 경우에 호출되는 콜백 함수  - 각 then은 새로운 프로미스 객체를 반환하여 체이닝을 가능하게 함   promise    .then((data) =&gt; {      console.log(data); // Data fetched successfully    })    .catch((error) =&gt; {      console.error(error); // Error in fetching data    });3️⃣ async awaitasync await는 Promise Then을 편하게 사용하게 해줌  async는 항상 Promise를 반환  async function fetchData() {    // 이 함수는 Promise를 반환    return 'Data fetched';  }  fetchData().then(data =&gt; console.log(data)); // Data fetched  await는 Promise가 처리될 때까지 함수 실행을 중지시켜줌  async function fetchData() {    let data = await new Promise((resolve, reject) =&gt; {      setTimeout(() =&gt; {        resolve('Data fetched');      }, 2000); 2초 중지 시켜줌    });    console.log(data); // Data fetched  }  fetchData();"
  },
  
  {
    "title": "[JavaScript] - 기본 문법 (3)",
    "url": "/posts/%EC%88%98%EC%97%85-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC-(3)/",
    "categories": "📖, JavaScript",
    "tags": "JavaScript",
    "date": "2024-07-17 00:00:00 +0900",
    





    
    "snippet": "🚀 함수1️⃣ 함수 선억식  function 키워드를 사용하여 함수 정의  호이스팅 ✅, 정의되기 전 호출 가능      function 함수이름(매개변수){//return 반한값;  }      2️⃣ 함수 표현식  변수에 익명 함수나 기명함수를 할당하는 방식으로 정의  호이스팅 ❎, 정의된 후에만 호출 가능      const 함수이름 = func...",
    "content": "🚀 함수1️⃣ 함수 선억식  function 키워드를 사용하여 함수 정의  호이스팅 ✅, 정의되기 전 호출 가능      function 함수이름(매개변수){//return 반한값;  }      2️⃣ 함수 표현식  변수에 익명 함수나 기명함수를 할당하는 방식으로 정의  호이스팅 ❎, 정의된 후에만 호출 가능      const 함수이름 = function(매개변수) {//return 반한값;  }      ✔️ 익명 함수 ? 이름 없는 함수, 주로 콜백 함수로 사용  const 익명함수 = function() {    //  };✔️ 기명 함수 ? 이름 있는 함수, 스택 트레이스에서 함수 이름 확인 가능  const 기명함수 = function() 함수이름() {    //  };3️⃣ 화살표 함수  =&gt; 문법 사용해 간결하게 함수 정의 가능  this 바인딩이 정적으로 결정  arguments 객체 사용 불가  생성자 함수로 사용 불가  메소드로 사용 불가  const 함수이름 = (매개변수) =&gt; {    //    return 반환값;  }  const 함수이름 = 매개변수 =&gt; 반한값;🚀 호이스팅자바스크립트에서 함수나 변수가 선언된 위치와 상관없이 코드가 실행되기 전에 해당 선언이 최상단으로 끌어올려지는 동작을 의미1️⃣ 변수 호이스팅  변수는 선언 부분만 호이스팅 ✅, 할당 부분은 호이스팅 ❎  console.log(test); // undefined  var test = 'Hi';  console.log(test); // 'Hi'  let과 const는 TDZ(Temporal Dead Zone)로 인해 선언 전에 참조 불가 ❗️   (let과 const로 선언된 변수는 코드가 실행되기 전에 선언이 메모리에 등록이되지만 접근이 불가하다)  console.log(myLetVar); // ReferenceError: myLetVar is not defined  let myLetVar = 'Hello';  console.log(myLetVar); // 'Hello'  console.log(myConstVar); // ReferenceError: myConstVar is not defined  const myConstVar = 'Hello';  console.log(myConstVar); // 'Hello'2️⃣ 함수 호이스팅  함수 선언식은 전체가 호이스팅 ✅  함수 표현식, 화살표 함수는 함수 선언 부분만 호이스팅 ✅, 함수 할당 부분 호이스팅 ❎  &lt;!-- 함수 선언식 --&gt;  myHoisting(); // 'Hi'  function myHoisting() {    console.log('Hi');  }  &lt;!-- 함수 표현식 --&gt;  myHoisting(); // TypeError : myHoisting is not a function  var myHoisting = function() {    console.log('Hi');  }  &lt;!-- 화살표 함수 --&gt;  myHoisting(); // TypeError : myHoisting is not a function  const MyHoisting = () =&gt; {    console.log('Hi');  }🚀 컨텍스트실행 컨텍스트는 자바스크립트 코드가 실행되는 환경을 제공하는 객체1️⃣ 실행 컨텍스트 생성 및 실행  환경 레코드(Environment Record) : 실행 컨텍스트가 생성될 때 변수, 함수 선언, 매개 변수 등의 정보를 기록하는 객체          생성 단계 : 현재 컨텍스트의 선언문을 환경 레코드에 기록                  완성된 기록 : var 키워드로 선언된 변수와 함수 선언은 초기화 전에도 참조 가능          미완성된 기록 : let과 const로 선언된 변수는 TDZ로 인해 초기화 완료되기 전까지 참조 불가                    실행 단계 : 생성 단계에서 기록된 환경 레코드를 참조해서 코드를 실행하거나 업데이트      2️⃣ 렉시컬 스코프(Lexical Scope)  자바스크립트에서 변수의 유효 범위는 렉시컬 스코프를 따름  즉, 함수가 선언된 위치에 따라 상위 스코프가 결정되며, 이는 함수가 호출될 때가 아니라 정의될 때 결정  함수 내부의 변수는 해당 함수가 정의된 위치에 따라 상위 스코프를 참조 ❗️  var globalVar = 'gloabal';  function outer() {    var outerVar = 'outer';    function inner() {      var innerVar = 'inner';      console.log(globalVar); // 'global'      console.log(outerVar); // 'outer'      console.log(innerVar); // 'inner'    }  }  inner 함수는 outer 함수의 스코프 체인 내에 있어서 outer 함수와 전역 스코프의 변수에 접근 가능  inner 함수는 globalVar와 outerVar에 접근할 수 있으며, 이것을 렉시컬 스코프라고 한다.3️⃣ Outer  외부 렉시컬 스코프를 참조하는 객체, 함수나 블록 내에서 선언된 변수들이 상위 스코프의 변수를 참조할 수 있게 해줌  모든 함수가 생성될 때 자신의 외부 렉시컬 환경을 기억하는데, 이 외부 렉시컬 환경을 통해 함수는 자신이 정의된 위치의 상위 스코프에 접근 가능  function outer() {    var outerVar = 'Here Outer';    function inner() {      console.log(outerVar); // 'Here Outer'    }    return inner;  }  const innerFunc = outer();  innerFunc();  inner 함수는 outer 함수 내부의 정의되어있어서 outer 함수의 외부 렉시컬 스코프에 접근 가능  JS의 클로저 특성에 의해 outer 함수가 실행 컨텍스트 종료 후에도 outer 함수의 outerVar에 접근 할 수 있음🚀 객체객체는 자바스크립트에서 데이터와 기능을 키-값 쌍의 형태로 구성된 여러 개의 속성을 저장하는 데이터 구조특징  객체는 키(key)와 값(value)로 이루어진 속성(properties)을 가짐  객체는 동적으로 속성을 추가 및 삭제 가능  객체는 다른 객체를 속성으로 가질 수 있음  객체는 함수를 속성으로 가질 수 있음 ➡️ 메서드  let person = {    name: \"Jude Bellingham\",    age: \"22\",    team: {      country: \"spain\",      club: \"Real-Madrid\"    }    job: \"Soccer Player\",    introduce: function() {      console.log(person.name + \"은 \" + person.team.club + person.job + \"이다.\");    }  };  // 동적 속성 Control  person.height = \"186cm\" // 추가  delete person.age; // 삭제  // 중첩 객체 속성 접근  console.log(person.team.country); // Spain  console.log(person.team.club); // Real-Madrid  // 메서드 호출  person.introduce(); // Jude Bellingham은 Real-Madrid Soccer Player이다.  [참조]MDN 공식 문서 - 호이스팅, 컨텍스트               JavaScript | MDN    JavaScript    developer.mozilla.org  한’s 개발 블로그 - 컨텍스트 https://hans-j.tistory.com/98"
  },
  
  {
    "title": "[JavaScript] - 기본 문법 (2)",
    "url": "/posts/%EC%88%98%EC%97%85-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC-(2)/",
    "categories": "📖, JavaScript",
    "tags": "JavaScript",
    "date": "2024-07-16 00:00:00 +0900",
    





    
    "snippet": "🚀 자료형의 종류자료형은 프로그래밍에서 변수나 값이 가질 수 있는 데이터의 종류를 의미1️⃣ 기본 자료형      숫자형    문자열형    논리형  2️⃣ 특수 자료형      undefined    심볼형    null  3️⃣ 참조 자료형      배열    함수    객체    typeof  🚀 연산자의 종류프로그래밍에서 값(피연산자)들에 대해...",
    "content": "🚀 자료형의 종류자료형은 프로그래밍에서 변수나 값이 가질 수 있는 데이터의 종류를 의미1️⃣ 기본 자료형      숫자형    문자열형    논리형  2️⃣ 특수 자료형      undefined    심볼형    null  3️⃣ 참조 자료형      배열    함수    객체    typeof  🚀 연산자의 종류프로그래밍에서 값(피연산자)들에 대해 특정 작업을 수행하는 데 사용되는 기호 또는 키워드를 의미1️⃣ 산술 연산자  + : 피연산자 덧셈- : 피연산자 뺄셈* : 피연산자 곱셈/ : 피연산자 나눗셈% : 피연산자끼리 나누어 떨어지는 나머지2️⃣ 증감 연산자 ➡️ 데이터가 할당 된 변수만 피연산자로 사용 가능 ❗️  ++ : 숫자형 데이터 1 증가-- : 숫자형 데이터 1 감소  추가로, 증감 연산자는 위치에 따라 후치 연산자, 전치 연산자로도 나눌 수 있음          후치 연산자 : 변수 뒤 위치 ✔️ 연산 끝난 후 변수 값 변경      전치 연산자 : 변수 앞 위치 ✔️ 변수 값 먼저 변경 후 다른 연산 수행      3️⃣ 대입 연산자  = : 할당 연산자+=, -=, *=, /=, %= : 복합 대입 연산자4️⃣ 비교 연산자  == : 동등 ➡️ 피연산자들의 값 동일 할 때 true 반환=== : 동치 ➡️ 피연산자들의 값, 자료형 동일 할 때 true 반환!= : 부등 ➡️ 피연산자들의 값 다를 때 true 반환!== : 불일치 ➡️ 피연산자들의 값, 자료형 다를 때 true 반환&gt;, &gt;=, &lt;, &lt;= : 크기 비교5️⃣ 삼항 연산자 - 세 개의 피연산자 필요, 조건에 따라 두 값 중 1개 반환 ❗️  condition ? exprIfTrue : exprIfFalse;   주로 간단한 조건부 로직 작성 시 사용 !6️⃣ 논리 연산자  &amp;&amp; : and|| : or! : not🚀 조건문 / 반복문1️⃣ 조건문 ➡️ 특정 조건 판별하여 각각 다른 로직 실행  if ~ else문  if (condition) {    // 조건이 참일 때 실행되는 로직  } else if (anotherCondition) {    // 또 다른 조건이 참일 때 실행되는 로직  } else {    // 위 조건들이 모두 거짓일 때 실행되는 로직  }  if문은 조건 참일 때 해당 로직 실행   else문은 if 조건이 거짓일 때 해당 로직 실행   else if문은 또 다른 조건 참일 때 해당 로직들 실행   switch  switch (expression) {  case value1:    // value1과 일치할 때 반환활 값    break;  case value2:    // value2와 일치할 때 반환활 값    break;  default:    // 어떤 case와도 일치하지 않을 때 반환활 값  }  여러 값 비교하여 반환활 값을 선택할 때 사용  각 값(case)에 대해 반환활 값을 지정하며, 일치하는 값이 없을 때는 default  ❗️ swith문은 값에 대한 비교만 가능하며, 표현식의 결과 비교 ❌2️⃣ 반복문 ➡️ 특정 코드를 여러 번 실행  while문  while (condition) {    // 조건이 참일 때 반복 실행되는 로직  }  조건이 참일 때까지 코드 블록을 반복  do…while문  do {    // 코드 블록  } while (condition);  코드 블록 먼저 실행하고 조건이 참일 때까지 반복  for문  for (initialization; condition; increment) {    // 반복 실행되는 로직  }  반복 횟수가 정해 초기화, 조건, 증감식을 포함하여 사용  for..in문  for (key in object) {    // 객체의 키를 반복  }  객체의 key 반복할 때 사용  for..of문  for (value of iterable) {    // 반복 실행되는 로직  }  배열이나 문자열 같은 반복 가능한 객체의 값을 반복할 때 사용"
  },
  
  {
    "title": "[JavaScript] - 기본 문법 (1) ",
    "url": "/posts/%EC%88%98%EC%97%85-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC/",
    "categories": "📖, JavaScript",
    "tags": "JavaScript",
    "date": "2024-07-15 00:00:00 +0900",
    





    
    "snippet": "🚀 JavaScript를 실행 시키는 방법1️⃣ node 명령어를 사용  우선 실행시킬 js 파일로 이동한다.    #  excd Desktop/my-app/next-study.js        node 명령어로 실행    node next-study.js      2️⃣ code runner 익스텐션을 사용 Code Runner  vscode Ext...",
    "content": "🚀 JavaScript를 실행 시키는 방법1️⃣ node 명령어를 사용  우선 실행시킬 js 파일로 이동한다.    #  excd Desktop/my-app/next-study.js        node 명령어로 실행    node next-study.js      2️⃣ code runner 익스텐션을 사용 Code Runner  vscode Extensions -&gt; code runner 검색 후 설치  실행시킬 js 파일에서 출력할 결과 console.log 작성 후 ⇧ + space3️⃣ html 파일에서 script 태그를 사용  외부 스크립트          head 태그 사이        &lt;head&gt;  &lt;meta charset=\"UTF-8\"&gt;  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=\"js 파일 경로\"&gt;&lt;/script&gt;&lt;/html&gt;              🔥 속성        async : async 속성을 사용하면 스크립트는 비동기적으로 로드된다. 즉, HTML 파싱이 진행되는 동안 스크립트 파일을 비동기적으로 다운로드하고, 다운로드가 완료되면 바로 실행된다.    defer : defer 속성을 사용하면 스크립트는 비동기적으로 로드되지만, HTML 파싱이 완료된 후에 실행된다. 이는 HTML 문서의 파싱이 끝날 때까지 스크립트가 실행되지 않음을 보장해준다.                            속성          실행 시점          실행 순서          비고                                      async          스크립트 다운로드 완료 즉시 실행          순서 보장 안됨          독립적인 스크립트에 적합                          defer          HTML 파싱 완료 후 실행          순서 보장됨          DOM 의존 스크립트에 적합                            body 태그 사이        &lt;body&gt;&lt;!-- body content --&gt;  &lt;script src=\"js 파일 경로\"&gt;&lt;/script&gt;&lt;/body&gt;        🐥 모든 DOM 요소가 파싱된 후 스크립트가 로드    내부 스크립트   ➡️ 🐥 말 그대로 HTML 파일 내부의 스크립트를 작성한다. 공부할 때 말고는 왠만하면 쓰지말자 !4️⃣ 웹 브라우저의 개발자 도구 ➡️ Console 탭에서 작성하는 방법✔️ 크롬 -&gt; 마우스 우클릭 -&gt; 검사 -&gt; Console 탭  🚀 변수 / 상수1️⃣ 상수  상수는 값을 한 번 할당하면 변경할 수 없는 변수  const 키워드를 사용하여 선언2️⃣ 변수  변수는 변하는 값을 저장할 수 있는 공간  JavaScript에서 변수를 선언할 때 var, let, const 키워드를 사용          var: 함수 스코프, 재선언 가능, 재할당 가능 let: 블록 스코프, 재선언 불가, 재할당 가능 const: 블록 스코프, 재선언 불가, 재할당 불가, 단, 객체나 배열의 경우 내부 값은 변경 가능      3️⃣ 사용 지침  var는 사용하지 않음  let은 재할당이 필요할 때 사용  const는 재할당이 필요 없을 때 사용  ❗️ 습관적으로 사용하도록 노력🚀 기타 기호  ; -&gt; 세미콜론  : -&gt; 콜론  ” -&gt; 큰따옴표  ’ -&gt; 작은따옴표  `` -&gt; 백틱  [] -&gt; 대괄호  {} -&gt; 중괄호  () -&gt; 소괄호"
  },
  
  {
    "title": "JWT + 카카오 소셜 로그인 (5)",
    "url": "/posts/JWT-+-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%86%8C%EC%85%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-(5)/",
    "categories": "프로젝트, PETSTAGRAM",
    "tags": "React, Spring Boot, JWT, Social Login, Kakao, OAuth2.0",
    "date": "2024-06-13 00:00:00 +0900",
    





    
    "snippet": "📌 Server Side4. 클라이언트로부터 전달 받은 인가 코드를 이용하여 카카오 서버에 토큰 요청  먼저 클라이언트로부터 인가 코드를 받아오는 엔드포인트에서, 카카오 서버에 액세스 토큰을 요청하는 서비스를 호출/* AuthController.java */@GetMapping(\"/kakao\")public ResponseEntity&lt;UserDTO...",
    "content": "📌 Server Side4. 클라이언트로부터 전달 받은 인가 코드를 이용하여 카카오 서버에 토큰 요청  먼저 클라이언트로부터 인가 코드를 받아오는 엔드포인트에서, 카카오 서버에 액세스 토큰을 요청하는 서비스를 호출/* AuthController.java */@GetMapping(\"/kakao\")public ResponseEntity&lt;UserDTO&gt; kakaoLogin(@RequestParam String code) {  UserDTO userDTO = authService.kakaoLogin(code);  return ResponseEntity.ok(userDTO);}/* AuthService - kakaoLogin 메소드 */public UserDTO kakaoLogin(String code) {  KakaoTokenDto kakaoTokenDto = getKakaoAccessToken(code);  String accessToken = kakaoTokenDto.getAccess_token();  /* ··· */}  getKakaoAccessToken : 카카오 서버에 액세스 토큰 요청 부분코드 보기    /* AuthService - getKakaoAccessToken 메소드 */public KakaoTokenDto getKakaoAccessToken(String code) {  HttpHeaders headers = new HttpHeaders();  headers.add(\"Content-type\", \"application/x-www-form-urlencoded;charset=utf-8\");  MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;&gt;();  params.add(\"grant_type\", \"authorization_code\");  params.add(\"client_id\", KAKAO_CLIENT_ID);  params.add(\"redirect_uri\", KAKAO_REDIRECT_URI);  params.add(\"code\", code);  params.add(\"client_secret\", KAKAO_CLIENT_SECRET);  HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = new HttpEntity&lt;&gt;(params, headers);  RestTemplate restTemplate = new RestTemplate();  ResponseEntity&lt;String&gt; response = restTemplate.exchange(          \"https://kauth.kakao.com/oauth/token\",          HttpMethod.POST,          request,          String.class  );/* ··· */}      5. 카카오 서버에서 백엔드 서버로 토큰 발행  getKakaoAccessToken : 카카오 서버로부터 액세스 토큰 발급 부분코드 보기    /* AuthService - getKakaoAccessToken 메소드 */public KakaoTokenDto getKakaoAccessToken(String code) {  /* ··· */  ObjectMapper objectMapper = new ObjectMapper();  objectMapper.registerModule(new JavaTimeModule());  objectMapper.configure(DeserializationFeatureFAIL_ON_UNKNOWN_PROPERTIES, false);  KakaoTokenDto kakaoTokenDto;  try {    kakaoTokenDto = objectMapper.readValue(response.getBody(), KakaoTokenDto.class);  } catch (Exception e) {    throw new RuntimeException(\"카카오 토큰을 받아오는 데 실패했습니다.\");  }  return kakaoTokenDto;}      6.❗️ 토큰 발급이 완료되면 사용자 정보 조회 후 JWT 토큰 생성코드 보기    /* AuthService - kakaoLogin 메소드 */public UserDTO kakaoLogin(String code) {  KakaoTokenDto kakaoTokenDto = getKakaoAccessToken(code);  String accessToken = kakaoTokenDto.getAccess_token();  KakaoAccountDto kakaoUserInfoDto = getKakaoUserInfo(accessToken);  /* ··· */  UserEntity user = userRepository.findByEmail(email).orElseGet(() -&gt; {  /* ··· */  });  String jwt = jwtUtils.generateToken(user);  String refreshToken = jwtUtils.generateRefreshToken(new HashMap&lt;&gt;(), user);  UserDTO response = UserDTO.toDTO(user);  response.setToken(jwt);  response.setRefreshToken(refreshToken);  return response;}            발급받은 accessToken을 사용하여 getKakaoUserInfo 메소드를 통해 카카오 서버의 사용자 정보를 조회    조회한 사용자 정보를 이용하여 DB에 해당 사용자 존재 여부 확인 후 사용자 처리    JWT 토큰 및 리프레시 토큰을 생성    UserDTO 객체를 생성 및 사용자 정보를 담고, 토큰을 설정하여 반환  ✔️ 끝으로  반환한 JWT 토큰을 클라이언트 쪽에서 받아서 사용자 로그인 처리를 완료한다.  이 과정은 클라이언트와 서버 간의 인증을 통해 사용자에게 보다 안전하고 편리한 로그인 경험을 제공한다.  또한, JWT 토큰을 사용함으로써 서버 간의 상태를 유지하지 않고도 인증을 처리할 수 있어 확장성과 보안성을 높일 수 있었다."
  },
  
  {
    "title": "JWT + 카카오 소셜 로그인 (4)",
    "url": "/posts/JWT-+-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%86%8C%EC%85%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-(4)/",
    "categories": "프로젝트, PETSTAGRAM",
    "tags": "React, Spring Boot, JWT, Social Login, Kakao, OAuth2.0",
    "date": "2024-06-12 00:00:00 +0900",
    





    
    "snippet": "React + SpringBoot + Kakao 소셜 로그인 동작 과정📌 Client Side1. 카카오 로그인 클릭 ➡ 카카오 서버에 인가코드 요청&lt;a href={KAKAO_AUTH_URL}&gt;  &lt;img src={icons.kakaoLogin} alt=\"KakaoLogo\" className=\"kakao-login-icon\" /&gt;...",
    "content": "React + SpringBoot + Kakao 소셜 로그인 동작 과정📌 Client Side1. 카카오 로그인 클릭 ➡ 카카오 서버에 인가코드 요청&lt;a href={KAKAO_AUTH_URL}&gt;  &lt;img src={icons.kakaoLogin} alt=\"KakaoLogo\" className=\"kakao-login-icon\" /&gt;&lt;/a&gt;const CLIENT_ID = import.meta.env.VITE_KAKAO_CLIENT_ID;const REDIRECT_URI = import.meta.env.VITE_KAKAO_REDIRECT_URI;export const KAKAO_AUTH_URL = `https://kauth.kakao.com/oauth/authorize?client_id=${CLIENT_ID}&amp;redirect_uri=${REDIRECT_URI}&amp;response_type=code`;  🐰 카카오 서버에 앱 키와 Redirect URI, 응답 유형을 포함하여 인가 코드를 요청하는데 이 요청은 사용자가 카카오 로그인 페이지에서 인증 및 동의를 완료한 후, 설정된 Redirect URI로 인가 코드를 전달받기 위한 것2. 설정한 Redirect URI인 /login/oauth2/callback/kakao 경로로 리다이렉션 하기 위한 KakaoCallback 컴포넌트 라우트 설정&lt;Route  path=\"/login/oauth2/callback/kakao\"  element={&lt;KakaoCallback setIsLoggedIn={setIsLoggedIn} /&gt;}/&gt;3-1. 렌더링한 KakaoCallback 컴포넌트에서 인가 코드 추출 및 사용자 처리  이 컴포넌트에서는 URL에 포함된 인증 코드를 추출하여 백엔드 서버에 액세스 토큰을 요청하고, JWT 토큰을 받게되면 로컬 스토리지에 저장하고, 로그인 처리를 업데이트 한 후 메인 홈으로 네비게이션한다.코드 보기    useEffect(() =&gt; {  const fetchKakaoToken = async () =&gt; {    const code = new URLSearchParams(location.search).get(\"code\");    if (code) {      try {        const response = await KakaoService.getAccessToken(code);        const token = response.token;        if (token) {          localStorage.setItem(\"token\", token);          setIsLoggedIn(true);          navigate(\"/\");        } else {          console.error(\"로그인 실패:\", response.message);        }      } catch (error) {        console.error(\"카카오 로그인 에러:\", error);      }    }  };  fetchKakaoToken();}, [location, navigate, setIsLoggedIn]);      3-2. 백엔드 서버로 인가 코드 전달  KakaoService는 인가 코드를 백엔드 서버로 전달하여 액세스 토큰을 요청코드 보기    static async getAccessToken(code) {    try {      const response = await axios.get(        `${KakaoService.BASE_URL}/login/kakao?code=${code}`      );      return response.data;    } catch (error) {      console.error(\"로그인 실패: \", error.message);      throw new Error(\"로그인 실패: \" + error.message);    }}      "
  },
  
  {
    "title": "JWT + 카카오 소셜 로그인 (3)",
    "url": "/posts/JWT-+-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%86%8C%EC%85%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-(3)/",
    "categories": "프로젝트, PETSTAGRAM",
    "tags": "React, Spring Boot, JWT, Social Login, Kakao, OAuth2.0",
    "date": "2024-06-11 00:00:00 +0900",
    





    
    "snippet": "          카카오 로그인 (1)            카카오 로그인 (2)  1. 카카오 디벨로퍼 설정              Kakao Developers    Kakao    developers.kakao.com    위의 링크에서 애플리케이션 등록을 해준다.애플리케이션 추가하기  플랫폼 ➡️ Web 등록      본인의 React, Spri...",
    "content": "          카카오 로그인 (1)            카카오 로그인 (2)  1. 카카오 디벨로퍼 설정              Kakao Developers    Kakao    developers.kakao.com    위의 링크에서 애플리케이션 등록을 해준다.애플리케이션 추가하기  플랫폼 ➡️ Web 등록      본인의 React, SpringBoot 도메인 등록    기본 도메인은 카카오 서버에 먼저 요청을 보내는 React 도메인 입력  플랫폼 등록  Redirect URI 설정Redirect URI 등록❗️Redirect URI란?  Redirect URI는 OAuth2.0 인가 과정을 완료한 후, 사용자의 인증 결과(인증 코드, 토큰 등)를 전달하기 위해 사용자를 리다이렉션하는 URL이다."
  },
  
  {
    "title": "JWT + 카카오 소셜 로그인 (2)",
    "url": "/posts/JWT-+-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%86%8C%EC%85%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-(2)/",
    "categories": "프로젝트, PETSTAGRAM",
    "tags": "React, Spring Boot, JWT, Social Login, Kakao, OAuth2.0",
    "date": "2024-06-10 00:00:00 +0900",
    





    
    "snippet": "📌 React와 Spring Boot를 사용하여 JWT를 기반으로 로그인 세션을 관리하는 과정1. React에서 API 요청React 클라이언트에서는 이메일과 비밀번호를 입력 후 로그인 API를 호출하여 사용자 인증을 처리코드 보기    import axios from 'axios';class UserService {    static BASE_URL...",
    "content": "📌 React와 Spring Boot를 사용하여 JWT를 기반으로 로그인 세션을 관리하는 과정1. React에서 API 요청React 클라이언트에서는 이메일과 비밀번호를 입력 후 로그인 API를 호출하여 사용자 인증을 처리코드 보기    import axios from 'axios';class UserService {    static BASE_URL = 'http://localhost:8088';    static async login(email, password) {        const response = await axios.post(`${this.BASE_URL}/user/login`, {            email,            password,        });        return response.data;    }}            axios.post를 사용하여 로그인 API를 호출  2. 로그인 및 토큰 재발급 컨트롤러서버단 컨트롤러에서는 로그인 및 토큰 재발급 요청을 처리코드 보기    @RestController@RequiredArgsConstructor@RequestMapping(\"/user\")public class UserController {    private UserService userService;    @PostMapping(\"/login\")    public ResponseEntity&lt;UserDTO&gt; login(@RequestBody UserDTO userDTO) {        return ResponseEntity.ok(userService.login(userDTO));    }    // 새로고침 토큰    @PostMapping(\"/refresh\")    public ResponseEntity&lt;UserDTO&gt; refreshToken(@RequestBody UserDTO userDTO) {        return ResponseEntity.ok(userService.refreshToken(userDTO));    }}            /login 엔드포인트에서 사용자 인증 후 JWT 토큰을 반환    /refresh 엔드포인트에서 새로고침 토큰을 사용해 새로운 JWT 토큰을 반환  3. UserService 클래스UserService 클래스에서는 사용자 로그인 및 토큰 재발급 로직을 구현코드 보기    public class UserService {    public UserDTO login(UserDTO userDTO) {        authenticationManager.authenticate(            new UsernamePasswordAuthenticationToken(userDTO.getEmail(), userDTO.getPassword())        );        UserEntity user = userRepository.findByEmail(userDTO.getEmail())            .orElseThrow(() -&gt; new IllegalArgumentException(\"사용자를 찾을 수 없습니다. 이메일: \" + userDTO.getEmail()));        // 조회된 사용자 정보를 바탕으로 JWT 토큰 생성        String jwt = jwtUtils.generateToken(user);        // 비어있는 맵과 사용자 정보를 바탕으로 새로고침 토큰 생성        String refreshToken = jwtUtils.generateRefreshToken(new HashMap&lt;&gt;(), user);        UserDTO response = UserDTO.toDTO(user);        response.setToken(jwt);        response.setRole(user.getRole());        response.setRefreshToken(refreshToken);        return response;    }    public UserDTO refreshToken(UserDTO userDTO) {        UserDTO response = new UserDTO();        // 토큰에서 사용자 이메일 추출        String ourEmail = jwtUtils.extractUsername(userDTO.getToken());        // 이메일로 사용자 정보 조회, 없으면 예외 발생        UserEntity users = userRepository.findByEmail(ourEmail)            .orElseThrow(() -&gt; new UsernameNotFoundException(\"사용자를 찾을 수 없습니다. 이메일: \" + ourEmail));        // 토큰 유효성 검사 후 유효하다면 새로운 토큰 생성        if (jwtUtils.isTokenValid(userDTO.getToken(), users)) {            String jwt = jwtUtils.generateToken(users);            response.setToken(jwt);             response.setRefreshToken(userDTO.getToken());           }        return response;    }}            로그인 시 사용자 인증을 처리하고 JWT 및 새로고침 토큰을 생성    새로고침 토큰 유효성을 검사하고, 유효하다면 새로운 JWT를 생성  4. JWTUtils 클래스JWTUtils 클래스에서는 JWT 생성 및 검증에 필요한 유틸리티 메서드를 구현코드 보기    package com.petstagram.service.utils;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.stereotype.Component;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.nio.charset.StandardCharsets;import java.util.Base64;import java.util.Date;import java.util.HashMap;import java.util.function.Function;@Componentpublic class JWTUtils {    private SecretKey key;    private static final long ACCESS_TOKEN_EXPIRATION_TIME = 1800000; // 30분    private static final long REFRESH_TOKEN_EXPIRATION_TIME = 604800000; // 7일    public JWTUtils(@Value(\"${jwt.secret}\") String secretString) {        byte[] keyBytes = Base64.getDecoder().decode(secretString.getBytes(StandardCharsets.UTF_8));        this.key = new SecretKeySpec(keyBytes, \"HmacSHA256\");    }    public String generateToken(UserDetails userDetails){        return Jwts.builder()                .setSubject(userDetails.getUsername())                .setIssuedAt(new Date(System.currentTimeMillis()))                .setExpiration(new Date(System.currentTimeMillis() + ACCESS_TOKEN_EXPIRATION_TIME))                .signWith(key)                .compact();    }    public String generateRefreshToken(HashMap&lt;String, Object&gt; claims, UserDetails userDetails){        return Jwts.builder()                .setClaims(claims)                .setSubject(userDetails.getUsername())                .setIssuedAt(new Date(System.currentTimeMillis()))                .setExpiration(new Date(System.currentTimeMillis() + REFRESH_TOKEN_EXPIRATION_TIME))                .signWith(key)                .compact();    }    public String extractUsername(String token){        return extractClaims(token, Claims::getSubject);    }    private &lt;T&gt; T extractClaims(String token, Function&lt;Claims, T&gt; claimsResolver){        return claimsResolver.apply(Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token).getBody());    }    public boolean isTokenValid(String token, UserDetails userDetails){        final String username = extractUsername(token);        return (username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token));    }    public boolean isTokenExpired(String token){        return extractClaims(token, Claims::getExpiration).before(new Date());    }}            generateToken 메서드는 액세스 토큰을 생성    generateRefreshToken 메서드는 새로고침 토큰을 생성    extractUsername 메서드는 토큰에서 사용자 이름을 추출    isTokenValid 메서드는 토큰 유효성을 검사합니다.출  5. OurUserDetailsService 클래스OurUserDetailsService 클래스는 사용자 인증에 필요한 사용자 정보를 데이터베이스에서 조회코드 보기    package com.petstagram.service.utils;import com.petstagram.repository.UserRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Service;@Servicepublic class OurUserDetailsService implements UserDetailsService {    @Autowired    private UserRepository userRepository;    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {        return userRepository.findByEmail(username)                .orElseThrow(() -&gt; new IllegalArgumentException(\"사용자를 찾을 수 없습니다. email = \" + username));    }}            loadUserByUsername 메서드는 이메일로 사용자 정보를 조회  "
  },
  
  {
    "title": "JWT + 카카오 소셜 로그인 (1)",
    "url": "/posts/JWT-+-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%86%8C%EC%85%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8/",
    "categories": "프로젝트, PETSTAGRAM",
    "tags": "React, Spring Boot, JWT, Social Login, Kakao, OAuth2.0",
    "date": "2024-06-09 00:00:00 +0900",
    





    
    "snippet": "          로그인 UI            카카오 로그인  JWT(Jason Web Token)JWT(JSON Web Token)는 두 개체 간에 정보를 JSON 객체로 안전하게 전송하기 위한 개방형 표준( RFC7519 )이고, 디지털 서명으로 검증되고 신뢰될 수 있다. JWT는 주로 사용자가 로그인한 후 요청마다 JWT를 포함시켜 허용된 리...",
    "content": "          로그인 UI            카카오 로그인  JWT(Jason Web Token)JWT(JSON Web Token)는 두 개체 간에 정보를 JSON 객체로 안전하게 전송하기 위한 개방형 표준( RFC7519 )이고, 디지털 서명으로 검증되고 신뢰될 수 있다. JWT는 주로 사용자가 로그인한 후 요청마다 JWT를 포함시켜 허용된 리소스에 접근하는 권한 부여와 당사자 간에 안전하게 정보를 전송하는 정보 교환에 사용된다. 서명된 토큰은 클레임의 무결성을 보장하고, 공개/비공개 키를 사용하면 발신자의 신원을 확인할 수 있다.JWT의 구성요소JWT(JSON Web Token)는 (.)으로 구분된 세 부분으로 구성되어있다.  헤더(Header): 토큰 유형과 서명 알고리즘을 포함  페이로드(Payload): 사용자 및 추가 데이터(클레임)를 포함  서명(Signature): 헤더와 페이로드의 무결성을 검증하는 서명JWT 동작 원리React와 Spring Boot로 JWT를 사용한 로그인 구현의 동작 과정은 다음과 같다.1. 로그인 및 토큰 발급  ID/PW 로그인 요청: 클라이언트(React)가 서버(Spring Boot)에 사용자 ID와 비밀번호를 보내 로그인 요청을 한다.  토큰 발급: 서버는 ID와 비밀번호를 검증한 후, Access Token과 Refresh Token을 생성하여 클라이언트에 응답한다.  API 요청: 클라이언트는 이후의 API 요청 시 Access Token을 HTTP 헤더에 포함하여 서버에 요청을 보낸다.2. 토큰 갱신  Access Token 만료 응답: 서버가 Access Token의 만료를 감지하고 클라이언트에 만료 응답을 보낸다.  토큰 재발급 요청: 클라이언트는 Refresh Token을 사용하여 새로운 Access Token과 Refresh Token의 재발급을 서버에 요청한다.  새 토큰 발급: 서버는 Refresh Token을 검증하고, 새로운 Access Token과 Refresh Token을 발급하여 클라이언트에 응답한다.이 과정은 Access Token의 짧은 유효기간으로 인해 자주 갱신이 필요할 때, Refresh Token을 통해 새로운 Access Token을 발급받아 지속적인 인증 상태를 유지하게 한다.  [참조]  https://jwt.io/introduction"
  },
  
  {
    "title": "VITE - Spring Boot CORS 설정",
    "url": "/posts/CORS-%EC%84%A4%EC%A0%95/",
    "categories": "프로젝트, PETSTAGRAM",
    "tags": "React, Spring Boot, CORS",
    "date": "2024-06-08 00:00:00 +0900",
    





    
    "snippet": "웹 개발에서의 CORS 설정CORS란?CORS(Cross-Origin Resource Sharing)는 웹 애플리케이션이 하나의 출처에서 실행되는 리소스가 다른 출처의 리소스에 접근할 수 있도록 허용하는 보안 기능이다. 웹 브라우저는 보안상의 이유로 기본적으로 다른 출처(도메인, 프로토콜, 포트)의 리소스에 접근하는 것을 제한한다. 이러한 제약을 동일...",
    "content": "웹 개발에서의 CORS 설정CORS란?CORS(Cross-Origin Resource Sharing)는 웹 애플리케이션이 하나의 출처에서 실행되는 리소스가 다른 출처의 리소스에 접근할 수 있도록 허용하는 보안 기능이다. 웹 브라우저는 보안상의 이유로 기본적으로 다른 출처(도메인, 프로토콜, 포트)의 리소스에 접근하는 것을 제한한다. 이러한 제약을 동일 출처 정책(Same-Origin Policy)이라고 하며, 이를 우회하기 위해 CORS가 도입되었다.CORS 설정하는 이유웹 애플리케이션 개발에서 CORS를 설정하는 주된 이유는 다음과 같다.  다른 출처의 API에 접근하기 위해:                  웹 애플리케이션은 자주 다른 출처의 API와 상호작용한다. 프론트엔드에서 서버 API를 호출할 때 서버가 다른 도메인에 있을 경우, 브라우저는 보안상의 이유로 기본적으로 이러한 요청을 차단한다. CORS 설정을 통해 이러한 요청을 허용할 수 있다.              보안 유지:                  CORS는 보안 정책을 유지하면서도 특정 출처에서의 요청을 허용할 수 있도록 한다. 이를 통해 민감한 데이터에 대한 무단 접근을 방지하고, 신뢰할 수 있는 출처에서만 리소스 접근을 허용할 수 있다.              개발 환경에서의 편의성:                  개발 중에는 프론트엔드와 백엔드 서버가 종종 다른 도메인에서 실행된다. 예를 들어, 본인 프로젝트의 로컬 환경에서 프론트엔드는 http://localhost:5173에서, 백엔드는 http://localhost:8088에서 실행하였다. 이 경우, CORS 설정을 통해 개발 중에 발생하는 도메인 간의 요청 문제를 해결할 수 있다. 이를 통해 프론트엔드와 백엔드를 원활하게 통합하고 테스트할 수 있다.            Vite에서 CORS 설정Vite를 사용할 때 CORS 문제를 해결하기 위해서는 vite.config.js 파일에서 프록시 설정을 해줄 수 있다.import { defineConfig } from \"vite\";import react from \"@vitejs/plugin-react\";export default defineConfig({    plugins: [react()],    server: {        proxy: {            \"/api\": {                target: \"http://localhost:8088\",                changeOrigin: true,                rewrite: (path) =&gt; path.replace(/^\\/api/, \"\"),            },        },    },});SpringBoot에서 CORS 설정메인 애플리케이션 클래스에서 CORS 설정을 추가할 수 있다.import com.petstagram.config.AuditorAwareImpl;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.data.domain.AuditorAware;import org.springframework.data.jpa.repository.config.EnableJpaAuditing;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.scheduling.annotation.EnableScheduling;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@EnableJpaRepositories@EnableJpaAuditing@EnableScheduling@SpringBootApplicationpublic class PetstagramApplication {    @Bean    public AuditorAware&lt;String&gt; auditorProvide() {        return new AuditorAwareImpl();    }    public static void main(String[] args) {        SpringApplication.run(PetstagramApplication.class, args);    }    @Bean    public WebMvcConfigurer corsConfigurer() {        return new WebMvcConfigurer() {            @Override            public void addCorsMappings(CorsRegistry registry) {                registry.addMapping(\"/**\")                         .allowedMethods(\"*\")                         .allowedOrigins(\"http://localhost:5173\");            }        };    }}"
  },
  
  {
    "title": "🐶 PETSTAGRAM 프로젝트",
    "url": "/posts/Petstagram-Project/",
    "categories": "프로젝트, PETSTAGRAM",
    "tags": "React, Spring Boot, Vite",
    "date": "2024-06-08 00:00:00 +0900",
    





    
    "snippet": "펫스타그램‘펫스타그램’은 반려동물과 사람이 함께 삶을 추구하는 시대를 반영하여 만든 웹 플랫폼입니다.사용자들은 반려동물 사진과 동영상을 업로드하고 공유하며, 다양한 반려동물 프로필을 확인하고 정보를 공유함으로써 새로운 친구를 사귈 수 있는 커뮤니티를 형성하고자 만들게 되었습니다.",
    "content": "펫스타그램‘펫스타그램’은 반려동물과 사람이 함께 삶을 추구하는 시대를 반영하여 만든 웹 플랫폼입니다.사용자들은 반려동물 사진과 동영상을 업로드하고 공유하며, 다양한 반려동물 프로필을 확인하고 정보를 공유함으로써 새로운 친구를 사귈 수 있는 커뮤니티를 형성하고자 만들게 되었습니다."
  },
  
  {
    "title": "🐥 My Tech Stack",
    "url": "/posts/MINDDO-TECH-STACK/",
    "categories": "Tech Stack, Minddo",
    "tags": "",
    "date": "2022-06-30 00:00:00 +0900",
    





    
    "snippet": "Front-end          Back-end            Databases         Development Tools          DevOps        Collaboration Tools    ",
    "content": "Front-end          Back-end            Databases         Development Tools          DevOps        Collaboration Tools    "
  }
  
]

